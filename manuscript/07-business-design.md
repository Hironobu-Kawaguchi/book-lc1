# サービス企画から設計まで（ビジネス視点）

## エージェント型サービスの企画プロセス

ユーザ価値とKPIと競合と運用コストを整理して要求を定義します。
エージェント型サービスを企画する際は、技術先行ではなく、ビジネス価値から逆算することが重要です。
LLM やエージェントは手段であり、目的はユーザーの課題解決と事業の成長です。

### ビジネス価値の明確化

エージェント型サービスを導入する目的を明確にします。

#### ユーザー価値の定義

誰のどのような課題を解決するのかを具体的に定義します。

- **ターゲットユーザー**: 誰が使うのか（社内従業員、顧客、パートナーなど）
- **ペインポイント**: どのような課題や不便があるのか
- **提供価値**: エージェントによってどのように改善されるのか
- **代替手段**: 現在どのように解決しているのか（手作業、既存システムなど）

例：カスタマーサポートエージェント
- ターゲット: 製品を購入した顧客
- ペインポイント: 営業時間外に問い合わせできない、回答まで時間がかかる
- 提供価値: 24時間365日即座に回答、よくある質問は自動応答
- 代替手段: メールサポート、電話サポート（営業時間内のみ）

### KPIの設定

エージェント導入の効果を測定する指標を設定します。

#### ユーザー体験指標

- **応答時間**: 質問から回答までの時間（秒単位で測定）
- **解決率**: エージェントだけで解決できた問い合わせの割合
- **満足度**: ユーザーのフィードバック（5段階評価など）
- **利用率**: 全体の問い合わせのうち、エージェントが対応した割合

#### ビジネス指標

- **コスト削減**: 人的対応の削減による費用削減額
- **対応件数**: 単位時間あたりの対応件数の増加
- **エスカレーション率**: 人間のオペレーターに引き継いだ割合
- **ROI**: 投資対効果（開発・運用コスト vs 削減コスト）

#### 技術指標

- **精度**: 正しい回答を生成した割合
- **レイテンシ**: システムの応答速度（ミリ秒単位）
- **可用性**: システムの稼働率（99.9% など）
- **エラー率**: エラーが発生した割合

### 競合分析とポジショニング

市場における競合と自社の優位性を整理します。

#### 競合の把握

- **既存ソリューション**: Zendesk、Intercom などのカスタマーサポートツール
- **汎用チャットボット**: ChatGPT、Claude などの汎用 LLM
- **専用エージェント**: 業界特化型のエージェントサービス

#### 差別化要因

自社のエージェントが提供できる独自の価値を明確にします。

- **ドメイン知識**: 業界固有の専門知識を持つ
- **統合性**: 既存システム（CRM、ERP など）とシームレスに連携
- **カスタマイズ性**: 顧客ごとにカスタマイズ可能
- **セキュリティ**: オンプレミス運用やデータの暗号化に対応

### 運用コストの見積もり

エージェントの開発と運用にかかるコストを見積もります。

#### 開発コスト

- **人件費**: エンジニア、デザイナー、PM の工数
- **インフラ**: 開発環境のクラウドコスト
- **LLM API 利用料**: OpenAI、Anthropic などの API 料金（プロトタイピング段階）
- **ツール・ライセンス**: 開発ツールやサードパーティサービスのライセンス料

#### 運用コスト

- **LLM API 利用料**: 本番環境でのトークン使用量に応じた料金
- **インフラ**: 本番環境のサーバー、データベース、ベクトルDB のコスト
- **モニタリング**: LangSmith、Datadog などの観測性ツールの費用
- **保守・改善**: 継続的な改善のためのエンジニアリソース

#### コスト試算例

月間10万件の問い合わせを処理するカスタマーサポートエージェントの場合：

- LLM API 料金: 1件あたり平均2,000トークン（入力1,000 + 出力1,000）× 10万件 × $0.01/1Kトークン = $2,000/月
- ベクトルDB（Pinecone）: 100万ベクトル格納 + 10万回検索 = $70/月
- インフラ（AWS）: EC2、RDS、S3 など = $500/月
- モニタリング（LangSmith）: $200/月
- 合計: 約$2,770/月（約40万円/月、1ドル=145円換算）

これに対して、人的対応の削減効果が月間100万円であれば、ROI は正のリターンとなります。

## 要求定義と機能設計

サービスに必要な機能を整理し、優先順位をつけます。

### 要求定義のフレームワーク

MoSCoW 法を使って、機能の優先順位を決定します。

- **Must have**: 最低限必要な機能（これがないとサービスが成り立たない）
- **Should have**: 重要だが必須ではない機能（あると価値が高まる）
- **Could have**: あると良い機能（余裕があれば実装）
- **Won't have**: 今回は実装しない機能（将来的には検討）

#### カスタマーサポートエージェントの例

**Must have:**
- FAQ 検索機能
- 自然言語での質問応答
- 営業時間、製品情報などの基本情報提供
- 人間のオペレーターへのエスカレーション機能

**Should have:**
- 注文履歴の照会
- 返品・交換手続きの案内
- 多言語対応（日本語・英語）
- 会話履歴の保存

**Could have:**
- 商品レコメンデーション
- プロアクティブな問い合わせ（「配送が遅れています」などの通知）
- 音声対応（音声入力・出力）

**Won't have:**
- 返金処理の自動実行（リスクが高いため人間の承認が必要）
- 複雑なクレーム対応（感情的なケースは人間が対応）

### ユースケースの具体化

代表的なユースケースをシナリオとして記述します。

#### ユースケース1: 営業時間の問い合わせ

1. ユーザーが「営業時間を教えてください」と入力
2. エージェントが FAQ 検索ツールを呼び出し
3. 「営業時間は平日9時から18時までです」という情報を取得
4. エージェントが自然な文章で回答を生成
5. ユーザーが満足度を5段階で評価

#### ユースケース2: 注文履歴の照会

1. ユーザーが「先週注文した商品の配送状況を教えて」と入力
2. エージェントがユーザー認証を確認（ログイン済みか）
3. エージェントが注文履歴検索ツールを呼び出し
4. 「注文番号12345の商品は本日発送予定です」という情報を取得
5. エージェントが回答を生成し、追跡番号も提示

#### ユースケース3: 複雑な問い合わせのエスカレーション

1. ユーザーが「製品が壊れたので返金してほしい」と入力
2. エージェントが返品ポリシーを検索して案内
3. ユーザーが「すぐに返金してほしい」と要求
4. エージェントが複雑な案件と判断し、人間のオペレーターに引き継ぎ
5. オペレーターが会話履歴を確認して対応

## 技術選定：LangChainかLangGraphか

LangGraphとLangChainを使うメリットとデメリットを比較して技術選定を行います。

### 技術選定の基準

プロジェクトの特性に応じて、LangChain と LangGraph のどちらを使うか選定します。

#### LangChain を選ぶべきケース

- **シンプルなワークフロー**: 質問応答、RAG、簡単なツール呼び出し
- **高速なプロトタイピング**: PoC を素早く作りたい
- **標準的なユースケース**: FAQ ボット、文書検索など
- **小規模チーム**: エンジニアが少なく、シンプルな実装を優先

#### LangGraph を選ぶべきケース

- **複雑なワークフロー**: 多段階の処理、条件分岐、ループ
- **長時間実行**: 処理に時間がかかり、中断・再開が必要
- **ヒューマンインザループ**: 人間の承認を待つフローがある
- **マルチエージェント**: 複数のエージェントが協調して動作
- **細かい制御**: 状態管理やエラーハンドリングを細かく制御したい

### 技術選定の決定フロー

以下のフローチャートで技術を選定します。

```
質問1: ヒューマンインザループや長時間実行が必要か？
  Yes -> LangGraph を選択
  No -> 質問2へ

質問2: 複雑な条件分岐やマルチエージェント構成が必要か？
  Yes -> LangGraph を選択
  No -> 質問3へ

質問3: 高速なプロトタイピングを優先するか？
  Yes -> LangChain を選択
  No -> LangGraph も検討（将来の拡張性を考慮）
```

### ハイブリッド構成の検討

LangChain と LangGraph を組み合わせることも可能です。

- **プロトタイピングは LangChain**: 素早く PoC を作成
- **本番化時に LangGraph へ移行**: 複雑な要件に対応するため書き換え
- **部分的に LangGraph 導入**: 複雑な部分だけ LangGraph、他は LangChain

## PoCから本番化までのロードマップ

PoCから本番化までのロードマップを作成しチーム体制を明確化します。

### フェーズ1: PoC（Proof of Concept）

期間: 2～4週間
目的: 技術的な実現可能性を検証

#### 主な活動

- **最小機能の実装**: Must have 機能のみを実装
- **データ準備**: サンプルデータ（FAQ 10件程度）を用意
- **技術検証**: LLM の精度、応答速度、コストを評価
- **デモ作成**: ステークホルダーに見せられるデモを作成

#### 成果物

- 動作するプロトタイプ（Jupyter Notebook や簡単な Web UI）
- 技術評価レポート（精度、速度、コスト）
- PoC デモビデオ

#### 成功基準

- 10件の FAQ に対して 80% 以上の精度で回答できる
- 平均応答時間が 3 秒以内
- 月間1万件の問い合わせを処理した場合のコスト試算が予算内

### フェーズ2: MVP（Minimum Viable Product）

期間: 2～3ヶ月
目的: 限定的なユーザーに提供して、実際の使用状況を観察

#### 主な活動

- **機能拡充**: Should have 機能の一部を実装
- **データ拡充**: FAQ を 100 件程度に増やす
- **UI/UX 設計**: ユーザーが使いやすいインターフェースを設計
- **モニタリング構築**: ログ、メトリクス、トレーシングを導入
- **限定公開**: 社内ユーザーや一部の顧客にβ版として提供

#### 成果物

- Web アプリケーション（本番に近い環境）
- ユーザードキュメント
- モニタリングダッシュボード

#### 成功基準

- 100 件の FAQ に対して 85% 以上の精度
- ユーザー満足度が 3.5/5 以上
- エスカレーション率が 20% 以下

### フェーズ3: 本番化

期間: 1～2ヶ月
目的: 全ユーザーに提供し、安定運用を実現

#### 主な活動

- **スケーラビリティ対応**: 負荷テスト、キャッシング、非同期処理の導入
- **セキュリティ強化**: 認証・認可、データ暗号化、脆弱性対策
- **運用体制構築**: オンコール体制、エスカレーションフロー、障害対応マニュアル
- **全体公開**: すべてのユーザーに提供開始

#### 成果物

- 本番環境のシステム
- 運用マニュアル
- 障害対応マニュアル

#### 成功基準

- 月間 10 万件の問い合わせを安定処理
- 可用性 99.9% 以上
- ユーザー満足度が 4/5 以上

### フェーズ4: 継続的改善

期間: 継続的
目的: フィードバックをもとに機能を改善し続ける

#### 主な活動

- **ユーザーフィードバック収集**: 満足度アンケート、問い合わせ内容の分析
- **精度向上**: 誤回答を分析し、プロンプトや RAG を改善
- **新機能追加**: Could have 機能や、ユーザーから要望の高い機能を実装
- **コスト最適化**: トークン使用量の削減、キャッシング戦略の見直し

## チーム体制とロール定義

エージェント型サービスの開発には、多様な役割が必要です。

### プロジェクトチームの構成

#### プロダクトマネージャー（PM）

- **役割**: ビジネス価値の定義、優先順位の決定、ステークホルダー調整
- **スキル**: ビジネス理解、プロジェクト管理、コミュニケーション
- **成果物**: 要求定義書、ロードマップ、KPI レポート

#### AI/MLエンジニア

- **役割**: エージェントのロジック実装、プロンプト設計、RAG 構築
- **スキル**: Python、LangChain/LangGraph、LLM の知識、プロンプトエンジニアリング
- **成果物**: エージェントのコード、ツール定義、プロンプトテンプレート

#### バックエンドエンジニア

- **役割**: API 開発、データベース設計、既存システムとの統合
- **スキル**: Python/Node.js、REST API、データベース設計
- **成果物**: API サーバー、データベーススキーマ、統合コード

#### フロントエンドエンジニア

- **役割**: ユーザーインターフェースの開発
- **スキル**: React/Vue.js、UI/UX デザイン
- **成果物**: Web アプリケーション、チャット UI

#### インフラエンジニア

- **役割**: インフラ構築、デプロイ自動化、モニタリング
- **スキル**: AWS/GCP、Docker、Kubernetes、CI/CD
- **成果物**: インフラ構成、デプロイパイプライン、モニタリング設定

#### データサイエンティスト

- **役割**: 精度評価、ユーザー行動分析、A/B テスト設計
- **スキル**: 統計学、Python、データ分析
- **成果物**: 精度評価レポート、ユーザー行動分析レポート

### 小規模チームでの体制

スタートアップや小規模プロジェクトでは、一人が複数の役割を兼任します。

- **PM + AI/MLエンジニア**: ビジネスと技術の両方を理解する人材
- **フルスタックエンジニア**: フロントエンド + バックエンド + インフラを担当
- **外部リソースの活用**: デザイナーやインフラの一部を外注

## 実装レベル3: PoC用スクリプトと設計ドキュメント

実装レベル3ではPoC用スクリプトと設計ドキュメントの雛形を提示します。

### PoC用スクリプトの雛形

PoC フェーズで使えるシンプルなエージェントスクリプトを示します。

```python
"""
カスタマーサポートエージェントの PoC スクリプト
機能: FAQ 検索、営業時間案内、人間へのエスカレーション
"""

from langchain_openai import ChatOpenAI, OpenAIEmbeddings
from langchain_community.vectorstores import FAISS
from langchain_core.tools import tool
from langchain_core.documents import Document
from langgraph.prebuilt import create_react_agent
from langchain_core.messages import HumanMessage

# サンプルFAQデータ
faq_docs = [
    Document(page_content="営業時間は平日9時から18時までです。土日祝日は休業しております。", metadata={"category": "hours"}),
    Document(page_content="返品は商品到着後14日以内にお申し出ください。未開封に限ります。", metadata={"category": "returns"}),
    Document(page_content="配送は通常3営業日以内です。北海道・沖縄は5営業日かかります。", metadata={"category": "shipping"}),
    Document(page_content="製品Aの保証期間は購入日から1年間です。", metadata={"category": "warranty"}),
]

# ベクトルストアの構築
embeddings = OpenAIEmbeddings()
vectorstore = FAISS.from_documents(faq_docs, embeddings)

@tool
def search_faq(query: str) -> str:
    """FAQ から関連情報を検索します。営業時間、返品、配送、保証などの質問に使用してください。"""
    results = vectorstore.similarity_search(query, k=2)
    if not results:
        return "関連する FAQ が見つかりませんでした。"
    return "\n\n".join([doc.page_content for doc in results])

@tool
def escalate_to_human() -> str:
    """複雑な問い合わせや緊急の案件を人間のオペレーターに引き継ぎます。"""
    return "人間のオペレーターに引き継ぎます。しばらくお待ちください。"

# エージェントの構築
llm = ChatOpenAI(model="gpt-4o", temperature=0)
agent = create_react_agent(llm, [search_faq, escalate_to_human])

# インタラクティブなループ
def run_poc_agent():
    """PoC エージェントを対話的に実行"""
    print("カスタマーサポートエージェント PoC")
    print("質問を入力してください。終了するには 'exit' と入力してください。\n")

    while True:
        user_input = input("あなた: ")
        if user_input.lower() in ["exit", "quit", "終了"]:
            print("ご利用ありがとうございました。")
            break

        # エージェント実行
        response = agent.invoke({
            "messages": [HumanMessage(content=user_input)]
        })

        # 最後のメッセージを表示
        answer = response["messages"][-1].content
        print(f"エージェント: {answer}\n")

if __name__ == "__main__":
    run_poc_agent()
```

このスクリプトは、コマンドラインで対話的にエージェントをテストできます。

### 設計ドキュメントの雛形

PoC から MVP に移行する際に必要な設計ドキュメントの雛形を示します。

#### システムアーキテクチャ図

```
┌─────────────┐
│   ユーザー   │
└──────┬──────┘
       │ HTTP/WebSocket
       ↓
┌──────────────────┐
│   Web UI         │
│  (React/Next.js) │
└──────┬───────────┘
       │ REST API
       ↓
┌──────────────────────┐
│  API サーバー         │
│  (FastAPI/Flask)     │
└──────┬───────────────┘
       │
       ↓
┌────────────────────────┐
│  エージェントエンジン   │
│  (LangChain/LangGraph) │
└──────┬─────────────────┘
       │
       ↓
┌─────────────────────────────────┐
│  ツール・統合                     │
│  - ベクトルDB (FAISS/Pinecone)  │
│  - RDB (PostgreSQL)             │
│  - 外部API (CRM, 注文システム)  │
└─────────────────────────────────┘
```

#### データフロー図

```
1. ユーザーが質問を入力
   ↓
2. Web UI → API サーバーに POST /chat
   ↓
3. API サーバー → エージェントに質問を渡す
   ↓
4. エージェントが LLM を呼び出し、ツール使用を判断
   ↓
5a. FAQ 検索ツール → ベクトルDB から関連ドキュメントを取得
5b. 注文履歴検索ツール → RDB から注文情報を取得
   ↓
6. エージェントがツール結果を基に LLM で回答生成
   ↓
7. API サーバー → Web UI に回答を返す
   ↓
8. Web UI に回答を表示
```

#### API 仕様書

```yaml
# POST /api/chat
# チャットメッセージを送信して、エージェントから応答を取得

Request:
  Body:
    {
      "message": "営業時間を教えてください",
      "session_id": "user-12345",
      "metadata": {
        "user_id": "user-12345",
        "timestamp": "2025-01-15T10:30:00Z"
      }
    }

Response:
  {
    "response": "営業時間は平日9時から18時までです。",
    "session_id": "user-12345",
    "sources": [
      {"type": "faq", "id": "faq-001"}
    ],
    "confidence": 0.95
  }
```

#### データベーススキーマ

```sql
-- 会話履歴テーブル
CREATE TABLE conversations (
    id SERIAL PRIMARY KEY,
    session_id VARCHAR(255) NOT NULL,
    user_id VARCHAR(255),
    message TEXT NOT NULL,
    response TEXT NOT NULL,
    confidence FLOAT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- フィードバックテーブル
CREATE TABLE feedback (
    id SERIAL PRIMARY KEY,
    conversation_id INTEGER REFERENCES conversations(id),
    rating INTEGER CHECK (rating >= 1 AND rating <= 5),
    comment TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- エスカレーションテーブル
CREATE TABLE escalations (
    id SERIAL PRIMARY KEY,
    conversation_id INTEGER REFERENCES conversations(id),
    reason TEXT,
    status VARCHAR(50) DEFAULT 'pending',
    assigned_to VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

## 予算計画とROI試算

プロジェクトの予算を計画し、投資対効果を試算します。

### 開発予算

- **人件費**: エンジニア 3 名 × 3 ヶ月 × 80 万円/月 = 720 万円
- **LLM API（開発・テスト）**: 10 万円
- **インフラ（開発・ステージング）**: 5 万円/月 × 3 ヶ月 = 15 万円
- **ツール・ライセンス**: 10 万円
- **合計**: 約 755 万円

### 運用予算（月額）

- **LLM API**: 40 万円/月（月間 10 万件の問い合わせ）
- **インフラ**: 20 万円/月
- **モニタリング**: 3 万円/月
- **保守・改善**: エンジニア 0.5 名 = 40 万円/月
- **合計**: 約 103 万円/月

### 削減効果

- **人的対応削減**: 月間 10 万件のうち 70%（7 万件）をエージェントが対応
- **オペレーター削減**: 3 名分の人件費削減 = 90 万円/月 × 3 名 = 270 万円/月
- **削減効果 - 運用コスト**: 270 万円 - 103 万円 = 167 万円/月

### ROI

- **初期投資**: 755 万円
- **月次削減効果**: 167 万円
- **回収期間**: 755 / 167 ≒ 4.5 ヶ月
- **年間削減効果**: 167 万円 × 12 ヶ月 = 2,004 万円

投資は約 5 ヶ月で回収でき、年間約 2,000 万円の削減効果が見込まれます。

## 本章のまとめ

本章では、ビジネス視点からエージェント型サービスの企画、要求定義、技術選定、ロードマップ、チーム体制を解説しました。
エージェント導入は技術先行ではなく、ビジネス価値とROIを重視することが成功の鍵です。
次章では、エンジニア視点から実装パターンとベストプラクティスを詳しく見ていきます。

